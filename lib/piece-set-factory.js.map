{"version":3,"sources":["../src/piece-set-factory.js"],"names":["sourceMapSupport","require","install","PieceSet","pieces","Map","isSealed","piece","has","code","Error","set","get","createPieceSet","length","kings","filter","x","isKing","rv","add","seal","exports"],"mappings":"AACA;;;;AAOA;;;;;;;;AALA,CAAC,YAAW;AACR,QAAMA,mBAAmBC,QAAQ,oBAAR,CAAzB;AACAD,qBAAiBE,OAAjB;AACH,CAHD;;IASMC,Q;AAGF,wBAAc;AAAA;;AACV,aAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd;AACA,aAAKC,QAAL,GAAgB,KAAhB;AACH;;;;4BACGC,K,EAA6B;AAC7B,gBAAI,CAAC,KAAKD,QAAV,EAAoB;AAChB,oBAAI,KAAKF,MAAL,CAAYI,GAAZ,CAAgBD,MAAME,IAAtB,CAAJ,EACI,MAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN,CADJ,KAGI,KAAKN,MAAL,CAAYO,GAAZ,CAAgBJ,MAAME,IAAtB,EAA4BF,KAA5B;AACP,aALD,MAKO,MAAM,IAAIG,KAAJ,CAAU,eAAV,CAAN;AACV;;;+BACY;AACT,iBAAKJ,QAAL,GAAgB,IAAhB;AACH;;;iCACQG,I,EAA+B;AACpC,mBAAO,KAAKL,MAAL,CAAYQ,GAAZ,CAAgBH,IAAhB,CAAP;AACH;;;;;;AAGL,SAASI,cAAT,CAAwBT,MAAxB,EAAiE;AAC7D,QAAIA,OAAOU,MAAP,KAAgB,CAApB,EACI,MAAM,IAAIJ,KAAJ,CAAU,8BAAV,CAAN;AACJ,QAAMK,QAA+B,iBAAEC,MAAF,CAASZ,MAAT,EAAiB,UAACa,CAAD;AAAA,eAAKA,EAAEC,MAAP;AAAA,KAAjB,CAArC;AACA,QAAIH,MAAMD,MAAN,KAAe,CAAnB,EACI,MAAM,IAAIJ,KAAJ,8DAAqEK,MAAMD,MAA3E,CAAN;AACJ,QAAMK,KAAe,IAAIhB,QAAJ,EAArB;AAN6D;AAAA;AAAA;;AAAA;AAO7D,6BAAkCC,MAAlC;AAAA,gBAASG,KAAT;;AACIY,eAAGC,GAAH,CAAOb,KAAP;AADJ;AAP6D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAS7DY,OAAGE,IAAH;AACA,WAAOF,EAAP;AACH;;AAEDG,QAAQnB,QAAR,GAAyBA,QAAzB;AACAmB,QAAQT,cAAR,GAAyBA,cAAzB","file":"piece-set-factory.js","sourcesContent":["// @flow\n'use strict';\n\n(function() {\n    const sourceMapSupport = require('source-map-support');\n    sourceMapSupport.install();\n})();\n\nimport _ from 'lodash';\n\n\n\nclass PieceSet {\n    pieces: Map;\n    isSealed: boolean;\n    constructor() {\n        this.pieces = new Map();\n        this.isSealed = false;\n    }\n    add(piece: IConcretePiece): void {\n        if (!this.isSealed) {\n            if (this.pieces.has(piece.code))\n                throw new Error('duplicate key: ${piece.code}');\n            else\n                this.pieces.set(piece.code, piece);\n        } else throw new Error('set is sealed');\n    }\n    seal(): void {\n        this.isSealed = true;\n    }\n    fromCode(code: string): ?IConcretePiece {\n        return this.pieces.get(code);\n    }\n}\n\nfunction createPieceSet(pieces: Array<IConcretePiece>): PieceSet {\n    if (pieces.length===0)\n        throw new Error('set needs at least one piece');\n    const kings: Array<IConcretePiece> = _.filter(pieces, (x)=>x.isKing);\n    if (kings.length!==1)\n        throw new Error(`set needs to have exactly one King; it instead contains ${kings.length}`);\n    const rv: PieceSet = new PieceSet();\n    for (let piece: IConcretePiece of pieces)\n        rv.add(piece);\n    rv.seal();\n    return rv;\n}\n\nexports.PieceSet       = PieceSet;\nexports.createPieceSet = createPieceSet;\n\n\n\n"]}