{"version":3,"sources":["../src/eval-model.js"],"names":["EvaluationModel","pieceValues","royalDistanceFromFarEndBonus","multipliersForDistFromPromotionZone","offBoardMultiplier","bonusForEachPossibleMove","malusForEachPossibleMoveOfTheOpponent","bonusForEnemyLionUnderCheck","malusForFriendlyLionUnderCheck","some","Array","from","keys","k","isKing","gb","pn","_piece","_get","piece","isPromotable","promotedPiece","promote","has","valueOfPromotedPiece","get","d","distanceFromPromotionZone","length","Error","royalDistanceFromFarEndForGameWin","Number","POSITIVE_INFINITY","b","boardImmediateWinSide","NEGATIVE_INFINITY","pieceValuesFriendlySide","_evalPieceValues","pieceValuesEnemySide","freedomOfMoveValuation","_evalFreedomOfMovement","evalRoyalCheckage","_evalRoyalCheckage","sideA","rv","piecesOnBoard","onBoardPieces","forEach","p","winIfKingReachesFarEnd","_royalBonusFromDistanceToFarEnd","promotionBonus","bonusFromDistanceToPromotionZone","piecesOffBoard","offBoardPieces","pieceValue","moveBonusFriendlySide","_numOfMoves","moveMalusEnemySide","checkBonusEnemyLionUnderCheck","isKingUnderAttack","checkMalusFriendlyLionUnderCheck","nextStates","size","exports"],"mappings":"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","file":"eval-model.js","sourcesContent":["// @flow\n'use strict';\n\nimport {GameBoard} from './board-lib.js';\n\nimport _ from 'lodash';\nimport assert from 'assert';\nimport {assertArrayOfNotAscendingPositiveValues} from './num-utils.js';\n\nclass EvaluationModel {\n    pieceValues                          : Map<IConcretePiece, number>;\n    royalDistanceFromFarEndBonus  : Array<number>;    \n    multipliersForDistFromPromotionZone  : Array<number>;\n    offBoardMultiplier                   : number;\n    bonusForEachPossibleMove             : number;\n    malusForEachPossibleMoveOfTheOpponent: number;\n    bonusForEnemyLionUnderCheck          : number;\n    malusForFriendlyLionUnderCheck       : number;\n    constructor(    pieceValues                          : Map<IConcretePiece, number>,\n                    royalDistanceFromFarEndBonus  : Array<number>,                    \n                    multipliersForDistFromPromotionZone  : Array<number>,\n                    offBoardMultiplier                   : number,\n                    bonusForEachPossibleMove             : number,\n                    malusForEachPossibleMoveOfTheOpponent: number,\n                    bonusForEnemyLionUnderCheck          : number,\n                    malusForFriendlyLionUnderCheck       : number) {\n        assert (!_.some(Array.from(pieceValues.keys()), (k)=>k.isKing), `Evaluation model contains a King piece`);\n        assertArrayOfNotAscendingPositiveValues(royalDistanceFromFarEndBonus);\n        assertArrayOfNotAscendingPositiveValues(multipliersForDistFromPromotionZone);\n        assert(bonusForEachPossibleMove>=0);\n        assert(malusForEachPossibleMoveOfTheOpponent<=0);\n        assert(bonusForEnemyLionUnderCheck>=0);\n        assert(malusForFriendlyLionUnderCheck<=0);\n        assert(offBoardMultiplier>=1);\n        this.pieceValues                           = pieceValues;\n        this.royalDistanceFromFarEndBonus   = royalDistanceFromFarEndBonus;\n        this.multipliersForDistFromPromotionZone   = multipliersForDistFromPromotionZone;\n        this.offBoardMultiplier                    = offBoardMultiplier;\n        this.bonusForEachPossibleMove              = bonusForEachPossibleMove;\n        this.malusForEachPossibleMoveOfTheOpponent = malusForEachPossibleMoveOfTheOpponent;\n        this.bonusForEnemyLionUnderCheck           = bonusForEnemyLionUnderCheck;\n        this.malusForFriendlyLionUnderCheck        = malusForFriendlyLionUnderCheck;\n    }\n    bonusFromDistanceToPromotionZone(gb: GameBoard, pn: Point): number {\n        const _piece: ?IConcretePieceOnSide = gb._get(pn);\n        assert(_piece);\n        if (_piece != null) {\n            assert(_piece !== null);\n            const piece: IConcretePiece = _piece.piece;\n            if (!piece.isPromotable()) {\n                return 0;\n            } else {\n                const promotedPiece: IConcretePiece = piece.promote();\n                assert(this.pieceValues.has(promotedPiece));\n                const valueOfPromotedPiece: ?number = this.pieceValues.get(promotedPiece);\n                if (valueOfPromotedPiece!=null) {\n                    assert(valueOfPromotedPiece!==null);\n                    const d = gb.distanceFromPromotionZone(pn);\n                    if (d>=this.multipliersForDistFromPromotionZone.length) {\n                        return 0;\n                    } else\n                        return this.multipliersForDistFromPromotionZone[d]*valueOfPromotedPiece;\n                } else throw new Error('bug');\n            }\n        } else throw new Error('bug');\n    }\n    _royalBonusFromDistanceToFarEnd(gb: GameBoard, pn: Point): number {\n        const d: number = gb.royalDistanceFromFarEndForGameWin(pn);\n        if (d===Number.POSITIVE_INFINITY)\n            throw new Error('bad choreography - should have already checked if this board is set for instant win on far end');\n\n        if (d>= this.royalDistanceFromFarEndBonus.length)\n            return 0;\n        else\n            return this.royalDistanceFromFarEndBonus[d];\n    }\n\n    evaluateBoard(gb: GameBoard): number { // evaluation is done from the perspective of side A so higher value is better for sideA, lower value is better for sideB\n        const b: ?boolean = gb.boardImmediateWinSide();\n        if (b!=null) { // escape for immediate win situations\n            assert(b!==null);\n            return b?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY;\n        } else {   // normal evaluation\n            const pieceValuesFriendlySide           = this._evalPieceValues(gb,  true);\n            const pieceValuesEnemySide              = this._evalPieceValues(gb, false);\n            const freedomOfMoveValuation            = this._evalFreedomOfMovement(gb);\n            const evalRoyalCheckage = this._evalRoyalCheckage(gb);\n            return pieceValuesFriendlySide - pieceValuesEnemySide + freedomOfMoveValuation + evalRoyalCheckage;\n        }\n    }\n\n\n    _evalPieceValues(gb: GameBoard, sideA: boolean): number {\n        let rv = 0;\n        let piecesOnBoard: Array<[IConcretePiece, Point]> = gb.onBoardPieces(sideA);\n        piecesOnBoard.forEach( ([p, pn] : [IConcretePiece, Point]) => {\n            if (p.isKing) {\n                if ( gb.winIfKingReachesFarEnd )\n                    rv += this._royalBonusFromDistanceToFarEnd(gb, pn);\n            } else {\n                assert(this.pieceValues.has(p));\n                rv += this.pieceValues.get(p);\n                const promotionBonus = this.bonusFromDistanceToPromotionZone(gb, pn);\n                rv += promotionBonus;\n            }\n        });\n        let piecesOffBoard: Array<IConcretePiece> = gb.offBoardPieces(sideA);\n        piecesOffBoard.forEach( (p: IConcretePiece) => {\n            assert(this.pieceValues.has(p));\n            const pieceValue: ?number = this.pieceValues.get(p);\n            if (pieceValue!=null) {\n                assert(pieceValue!==null);\n                rv += pieceValue*this.offBoardMultiplier;\n            } else throw new Error('bug');\n        });\n        return rv;\n    }\n\n    _evalFreedomOfMovement(gb: GameBoard): number {\n        const moveBonusFriendlySide   = this._numOfMoves (gb,  true) * this.bonusForEachPossibleMove;\n        const moveMalusEnemySide      = this._numOfMoves (gb, false) * this.malusForEachPossibleMoveOfTheOpponent;\n        return moveBonusFriendlySide + moveMalusEnemySide;\n    }\n\n    _evalRoyalCheckage(gb: GameBoard): number {\n        const checkBonusEnemyLionUnderCheck     = gb.isKingUnderAttack(false)?this.bonusForEnemyLionUnderCheck:0;\n        const checkMalusFriendlyLionUnderCheck  = gb.isKingUnderAttack( true)?this.malusForFriendlyLionUnderCheck:0;\n        return checkBonusEnemyLionUnderCheck + checkMalusFriendlyLionUnderCheck;\n    }\n\n    _numOfMoves(gb: GameBoard, sideA: boolean): number {\n        return gb.nextStates(sideA, false).size;\n    }\n\n\n}\n\nexports.EvaluationModel = EvaluationModel;\n"]}