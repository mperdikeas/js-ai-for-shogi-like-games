{"version":3,"sources":["../src/board-lib.js"],"names":["sourceMapSupport","require","install","GameBoard","width","height","winIfKingReachesFarEnd","breadthOfPromotionZone","board","captured","newBoard","Map","forEach","v","k","set","fromString","reflectionInGrid","toString","switchSides","reflection","sideA","filter","Array","from","entries","pn","p","isSideA","map","piece","capturedPieces","onBoardPieces","offBoardPieces","rv","i","j","_has","push","some","emptyPoints","x","equals","toStringFancy","pieceOnSide","_get","Error","A","B","pieceSet","position","includes","s","assertPieceSetSupersetOfBoardPieces","sideOfMove","fromStringNoPieceSetInfo","m","has","isCellEmpty","to","side","vector","sideOnCell","theOther","_moves","moves","opposite","move","pTo","add","Number","POSITIVE_INFINITY","Math","max","y","isKing","evalModel","nextStates","evaluateBoard","_ignoreDrops","ignoreDrops","boardsForThisPiece","nextStatesByMovingPieceOnAParticularSquare","dropOptions","pc","drop","keyOfDropMove","clone","pnkey","get","delete","hasBeenDroppedBackInTheBoard","assertInGrid","_set","_delete","clear","capture","between","inGrid","pn1","pn2","locationOfKing","b","isKingUnderAttack","piecesOfThisSide","kingsOfThisSide","length","isPieceUnderAttack","nextBoards","boardsOnly","every","gb","pieceOnNewBoard","otherPiece","sameSide","_capture","isPromotionTriggered","promote","sideAKingIsCaptured","kingIsCaptured","sideBKingIsCaptured","kingAUncheckedLastLine","kingIsOnLastLineUnchecked","kinthisUncheckedLastLine","keys","keysSorted","sortBy","xy","key","join","o","boardNotation","_captureBag","captureBag","split","sideB","populate","moves2Boards","kvs","asSideA","positionNotationsStr","positionNotations","replace","piecePosition","point","isInteger","pieceP","fromCode","takeSides","rows","column","__gameBoards","_gameBoards","gameBoards","gameBoardsSliced","gameBoardsSlicedTr","movesToGameBoardsMap","movesToGameBoardsArr","exports","Point","PieceSet"],"mappings":"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","file":"board-lib.js","sourcesContent":["// @flow\n'use strict';\n\n(function() {\n    const sourceMapSupport = require('source-map-support');\n    sourceMapSupport.install();\n})();\n\nimport assert from 'assert';\nimport _ from 'lodash';\n\nimport not_used from './number-prototype.js';\n\nimport {MAX_BOARD_DIMENSION} from './constants.js';\n\nimport {Point, Vector}             from 'geometry-2d';\nimport {Piece, PieceOnSide}        from './piece.js';\nimport {Chick, Hen, Lion}          from './piece-set.js';\nimport {PieceSet}                  from './piece-set-factory.js';\nimport {transpose}                 from './transpose.js';\nimport {CaptureBag}                from './captureBag.js';\nimport {EvaluationModel}           from './eval-model.js';\nimport {Node}                      from './trees.js';\nimport {Side}                      from './side.js';\nimport {Move, BoardMove, DropMoveNoPieceInformation, DropMove} from './moves.js';\n\nclass GameBoard {\n    width                    : number;\n    height                   : number;\n    winIfKingReachesFarEnd   : boolean;\n    breadthOfPromotionZone   : number;\n    board                    : Map<string, IConcretePieceOnSide>;\n    captured                 : CaptureBag;\n\n    constructor(width: number,\n                height: number,\n                winIfKingReachesFarEnd: boolean,\n                breadthOfPromotionZone: number,\n                board: Map<string, IConcretePieceOnSide>,\n                captured: CaptureBag) {\n        this.width                  = width;\n        this.height                 = height;\n        this.winIfKingReachesFarEnd = winIfKingReachesFarEnd;\n        assert((breadthOfPromotionZone>=0) &&(breadthOfPromotionZone<=height));\n        this.breadthOfPromotionZone = breadthOfPromotionZone;\n        this.board                  = board;\n        this.captured               = captured;\n    }\n\n    static create(width: number, height: number, winIfKingReachesFarEnd: boolean, breadthOfPromotionZone: number, pieceSet: PieceSet, boardNotation: string, _captureBag: ?CaptureBag): GameBoard {\n        let captureBag = _captureBag || new CaptureBag();\n        const [sideA, sideB] = boardNotation.split('*');\n        assert(width.between (0, MAX_BOARD_DIMENSION));\n        assert(height.between(0, MAX_BOARD_DIMENSION));\n        const board: Map<string, IConcretePieceOnSide> = new Map();\n        GameBoard.populate(board, width, height, pieceSet, true , sideA);\n        GameBoard.populate(board, width, height, pieceSet, false, sideB);\n\n        return new GameBoard(width, height, winIfKingReachesFarEnd, breadthOfPromotionZone, board, captureBag);\n    }\n\n    reflection(): GameBoard { // returns a game board that is the reflection of this one\n        const newBoard: Map<string, IConcretePieceOnSide> = new Map();\n        this.board.forEach( (v, k) => {\n            newBoard.set(Point.fromString(k).reflectionInGrid(this.width, this.height).toString(), v.switchSides());\n        });\n        return new GameBoard(this.width, this.height, this.winIfKingReachesFarEnd, this.breadthOfPromotionZone, newBoard, this.captured.reflection());\n    }\n\n    onBoardPieces(sideA: boolean): Array<[IConcretePiece, Point]> {\n        return _.filter(Array.from(this.board.entries()), ([pn, p])=>p.isSideA===sideA).map( ([pn,p]) => [p.piece, Point.fromString(pn)] );\n    }\n    offBoardPieces(sideA: boolean): Array<IConcretePiece> {\n        return _.filter(this.captured.capturedPieces,  p=>p.isSideA===sideA).map( p => p.piece );\n    }\n\n    sideAPiecesOnBoard(): Array<[IConcretePiece, Point]> {\n        return this.onBoardPieces(true);\n    }\n    sideAPiecesOffBoard(): Array<IConcretePiece> {\n        return this.offBoardPieces(true);\n    }\n    sideBPiecesOnBoard(): Array<[IConcretePiece, Point]> {\n        return this.onBoardPieces(false);\n    }\n    sideBPiecesOffBoard(): Array<IConcretePiece> {\n        return this.offBoardPieces(false);\n    }\n\n\n    emptyPoints(): Array<Point> {\n        const rv: Array<Point> = [];\n        for (let i = 0; i < this.width; i++) {\n            for (let j = 0 ; j < this.height; j++) {\n                const p: Point = new Point(i, j);\n                if (!this._has(p))\n                    rv.push(p);\n            }\n        }\n        return rv;\n    }\n\n    isCellEmpty(p: Point): boolean {\n        return _.some(this.emptyPoints(), (x)=>x.equals(p));\n    }\n\n    sideOnCell(p: Point): Side {\n        assert(this._has(p), `B-SOS-CNP: The board:\\n${this.toStringFancy()}\\n contains no piece on square: ${p.toString()}`);\n        const pieceOnSide: IConcretePieceOnSide = this._get(p) || ( ()=>{throw new Error('should have escaped by now');})();\n        if (pieceOnSide.isSideA)\n            return Side.A;\n        else\n            return Side.B;\n    }\n\n    assertPieceSetSupersetOfBoardPieces(pieceSet: Array<IConcretePiece>) {\n        this.board.forEach( (pieceOnSide: IConcretePieceOnSide, position: string) => {\n            if (!_.includes(pieceSet, pieceOnSide.piece))\n                throw new Error(`The piece set ${pieceSet} does not include ${pieceOnSide.piece}`);\n        });\n    }\n\n    sideOfMoveS(pieceSet: Array<IConcretePiece>, s: string): Side {\n        this.assertPieceSetSupersetOfBoardPieces(pieceSet);\n        return this.sideOfMove(Move.fromString(pieceSet, s));\n    }\n    sideOfMoveSNoPieceSetInfo(s: string): Side {\n        return this.sideOfMove(Move.fromStringNoPieceSetInfo(s));\n    }\n\n    sideOfMove(m: Move): Side {\n        if (m instanceof DropMove) {\n            assert(this.captured.has(m.pieceOnSide), `B#ISMS#CNHP: the capture bag of board ${this} does not have the piece involved in the drop ${m}`);\n            assert(this.isCellEmpty(m.to), `B#ISMS#DNEC: impossible drop ${m} to non-empty cell on board ${this}`);\n            return m.pieceOnSide.isSideA?Side.A:Side.B;\n        }         \n        if (m instanceof DropMoveNoPieceInformation) {\n            assert(this.isCellEmpty(m.to), `B#ISMS#DNEC: impossible drop ${m} to non-empty cell on board ${this}`);\n            return m.side;\n        } else if (m instanceof BoardMove) {\n            assert(!this.isCellEmpty(m.vector.from));\n            const rv: Side = this.sideOnCell(m.vector.from);\n            assert(this.isCellEmpty(m.vector.to) || (this.sideOnCell(m.vector.to)===rv.theOther()), `B#ISMS#IV invalid move ${m.vector} on board ${this}`);\n            return rv;\n        }\n        else throw new Error(`Unrecognized move: ${m.toString()}`);\n    }\n\n    nextStatesByMovingPieceOnAParticularSquare(p : Point): Map<string, GameBoard> {\n        assert(this._has(p), `B-NSBMP-CNP: The board:\\n${this.toStringFancy()}\\n contains no piece on square: ${p.toString()}`);\n        const pieceOnSide: IConcretePieceOnSide = this._get(p) || ( ()=>{throw new Error('should have escaped by now');})();\n        const rv: Map<string, GameBoard> = new Map();\n        const piece: IConcretePiece = pieceOnSide.piece;    \n        const _moves: Array<Point> = piece.moves();\n        const moves: Array<Point> = pieceOnSide.isSideA?_moves:_moves.map(x=>x.opposite());\n        for (let move: Point of moves) {\n            const pTo: Point = p.add(move, false);\n            const v: Vector = new Vector(p, pTo);\n            const newBoard: ?GameBoard = this.move(p, pTo);\n            if (newBoard != null) { // made the test laxer than I normally would, to satisfy Flow\n                assert(newBoard !==null); // but now I am asserting that the stronger condition also holds\n                rv.set(v.toString(), newBoard);\n            }\n        }\n        return rv;\n    }\n\n\n    static boardsOnly(moves2Boards: Map<string, GameBoard>): Array<GameBoard> {\n        const kvs: Array<[string, GameBoard]> = Array.from(moves2Boards.entries());\n        return kvs.map ( ([k,v]) => v );\n    }\n\n    // returns the distance of the piece on that particular point from its respective promotion zone\n    distanceFromPromotionZone(p : Point): number {\n        const piece: ?IConcretePieceOnSide = this._get(p);\n        assert(piece, `B-NPEOP: no piece exists on point ${p} on board:\\n ${this.toStringFancy()}`);\n        if (this.breadthOfPromotionZone === 0)\n            return Number.POSITIVE_INFINITY; // if a board has no promotion zone, the distance is infinite\n        if (piece != null) { // Flow compels me to make the check this way\n            assert(piece !== null); // ... but I am going to assert that a stronger, still, condition holds\n            if (piece.isSideA) {\n                return Math.max(p.y+1 - this.breadthOfPromotionZone, 0);\n            } else {\n                return Math.max(this.height-this.breadthOfPromotionZone-p.y, 0);\n            }\n        } else\n            throw new Error('bug - should have escaped by now');\n    }\n\n    // returns the distance of a king from its respective far end or positive infinity if the board is not configured\n    // to result in an automatic win should a king reache the far end\n    royalDistanceFromFarEndForGameWin(p : Point): number {\n        const piece: ?IConcretePieceOnSide = this._get(p);\n        assert(piece             , `B-RD-NPEOP: no piece exists on point ${p} on board:\\n ${this.toStringFancy()}`);\n        if (piece != null) { // Flow compels me to make the check this way\n            assert(piece !== null); // ... but I am going to assert that a stronger, still, condition holds\n            assert(piece.piece.isKing, `B-RD-NK: the piece that exists on point ${p} on board:\\n ${this.toStringFancy()}\\n ... is [${piece.piece}] and is not a King`);\n            if (!this.winIfKingReachesFarEnd)\n                return Number.POSITIVE_INFINITY;\n            if (piece.isSideA) {\n                return p.y;\n            } else {\n                return this.height-p.y-1;\n            }\n        } else\n            throw new Error('bug - should have escaped by now');\n    }    \n\n\n    nextStatesValues(sideA: boolean, evalModel: EvaluationModel): Map<string, [GameBoard, number]> {\n        const rv: Map<string, [GameBoard, number]> = new Map();\n        const nextStates: Map<string, GameBoard> = this.nextStates(sideA, false);\n        nextStates.forEach( (v, k) => {\n            assert (!rv.has(k));\n            rv.set(k, [v, evalModel.evaluateBoard(v)]);\n        });\n        return rv;\n    }\n    nextStates(sideA: boolean, _ignoreDrops: ?boolean): Map<string, GameBoard> {\n        // rationale for the [ignoreDrops]: for estimating whether a piece is under attack we need not consider drops\n        // so having this switch saves some time.\n        let ignoreDrops: boolean = _ignoreDrops==null?false:_ignoreDrops;\n        const rv: Map<string, GameBoard> = new Map();\n        // add all possible moves\n        this.board.forEach( (v: IConcretePieceOnSide, k: string) => {\n            const p: Point = Point.fromString(k);\n            if (v.isSideA===sideA) {\n                const boardsForThisPiece: Map<string, GameBoard> = this.nextStatesByMovingPieceOnAParticularSquare(p);\n                boardsForThisPiece.forEach( (v, k)=> {\n                    assert(!rv.has(k), `Weird, move ${k} has already been encountered`);\n                    rv.set(k, v);\n                } );\n            }\n        });\n        if (!ignoreDrops) {\n            const dropOptions: Array<IConcretePiece> = this.captured.dropOptions(sideA);\n            const emptyPoints: Array<Point> = this.emptyPoints();\n            dropOptions.forEach( (pc: IConcretePiece)=> {\n                emptyPoints.forEach( (pn: Point)=>{\n                    const newBoard: ?GameBoard = this.drop(new PieceOnSide(pc, sideA), pn);\n                    if (newBoard != null) { // Flow demands this be laxer than I would like\n                        assert(newBoard!==null, 'bad choreography'); // doing the stricter test\n                        const keyOfDropMove = `${new PieceOnSide(pc, sideA)}=>${pn}`;\n                        assert(!rv.has(keyOfDropMove), `Weird, drop move ${keyOfDropMove} has alredy been encountered`);\n                        rv.set(keyOfDropMove, newBoard);\n                    } else\n                        throw new Error('bad choreography');\n                })\n            });\n        }\n        return rv;\n    }\n\n    clone(): GameBoard {\n        return new GameBoard(this.width\n                             , this.height\n                             , this.winIfKingReachesFarEnd\n                             , this.breadthOfPromotionZone\n                             , new Map(this.board)\n                             , this.captured.clone());\n    }\n    \n    _get(pn: Point): ?IConcretePieceOnSide {\n        const pnkey = pn.toString();\n        return this.board.get(pnkey);\n    }    \n    _set(pn: Point, pc: IConcretePieceOnSide): void {\n        const pnkey = pn.toString();\n        this.board.set(pnkey, pc);\n    }\n    _has(pn: Point): boolean {\n        const pnkey = pn.toString();\n        return this.board.has(pnkey);\n    }\n    _delete(pn: Point): ?any {\n        const pnkey = pn.toString();\n        return this.board.delete(pnkey);\n    }\n    drop(pc: IConcretePieceOnSide, pn: Point): ?GameBoard {\n        assert(this.captured.has(pc), `piece ${pc.toString()} not found in capture bag ${this.captured.toString()}`);\n        if (this._has(pn)) {\n            return null;\n        }\n        const rv : GameBoard = this.clone();\n        rv.set(pn, pc);\n        rv.captured.hasBeenDroppedBackInTheBoard(pc);\n        return rv;\n    }\n    set(pn: Point, pc: IConcretePieceOnSide): void {\n        this.assertInGrid(pn);\n        if (this._has(pn))\n            throw new Error(`some other Piece already exists at ${pn}`);\n        this._set(pn, pc);\n    }\n    clear(pn: Point): void {\n        this.assertInGrid(pn);\n        if (!this._has(pn))\n            throw new Error(`Point ${pn} is already empty`);\n        else\n            assert(this._delete(pn)!=null);\n    }\n    _capture(pn: Point): void {\n        this.assertInGrid(pn);\n        assert(this._has(pn));\n        const piece: ?IConcretePieceOnSide = this._get(pn);\n        if (piece != null) {\n            this.clear(pn);\n            this.captured.capture(piece);\n        } else throw new Error();\n    }\n    inGrid(pn: Point): boolean {\n        return pn.x.between(0, this.width) && pn.y.between(0, this.height);        \n    }\n    assertInGrid(pn: Point): void {\n        const inGrid = this.inGrid(pn);\n        if (!inGrid)\n            throw new Error(`Point ${pn.toString()} does not lie in a ${this.width}X${this.height} grid`);\n    }\n\n    isPromotionTriggered(pn1: Point, pn2: Point) {\n        assert (!pn1.equals(pn2));\n        if (!this._has(pn1))\n            throw new Error(`board ${this} does not contain piece at starting point: ${pn1}`);\n        else {\n            const piece: ?IConcretePieceOnSide = this._get(pn1);\n            if (piece!=null) {           // Flow forces me to be laxer than I would like\n                assert(piece!==null);    // I take care of this forced laxness here ...\n                const sideA: boolean = piece.isSideA;\n                if (sideA)\n                    return _.some([pn1, pn2], (v) => {\n                        return v.y<this.breadthOfPromotionZone;\n                    });\n                else\n                    return _.some([pn1, pn2], (v) => {\n                        return v.y>=this.height-this.breadthOfPromotionZone;\n                    });\n            } else\n                throw new Error('bug - should have escaped this path by now');\n        }\n    }\n\n    kingIsOnLastLineUnchecked(sideA: boolean): boolean {\n        const p: Point   = this.locationOfKing   (sideA);\n        const b: boolean = this.isKingUnderAttack(sideA);\n        if ( ( sideA) && (p.y===0            ) && (!b) ) return true;\n        if ( (!sideA) && (p.y===this.height-1) && (!b) ) return true;\n        return false;\n    }\n\n    locationOfKing(sideA: boolean): Point {\n        const piecesOfThisSide: Array<[string, IConcretePiece]> = _.filter(Array.from(this.board.entries()),\n                                                                           ([k, v])=> v.isSideA===sideA\n                                                                          ).map( ([k, v])=>[k, v.piece] );\n        const kingsOfThisSide: Array<[string, IConcretePiece]> = _.filter(piecesOfThisSide, ([k,v])=>v===Lion);\n        assert(kingsOfThisSide.length===1, `Unexpected number of kings found: ${kingsOfThisSide.length}`);\n        return Point.fromString(kingsOfThisSide[0][0]);\n    }\n\n    isKingUnderAttack(sideA: boolean): boolean {\n        const p : Point = this.locationOfKing(sideA);\n        return this.isPieceUnderAttack(p);\n    }\n\n    isPieceUnderAttack(pn: Point): boolean { // we are assuming that the opposite side moves\n        if (!this._has(pn))\n            throw new Error(`board ${this} does not contain piece at starting point: ${pn}`);\n        else {\n            const piece: ?IConcretePieceOnSide = this._get(pn);\n            if (piece!=null) {           // Flow forces me to be laxer than I would like\n                assert(piece!==null);    // I take care of this forced laxness here ...\n                const nextBoards: Array<GameBoard> = GameBoard.boardsOnly(this.nextStates(!piece.isSideA, true));\n                \n                // if the piece remains in the same spot for *every* possible next state, then it is not\n                // currently under attack\n                return !_.every(nextBoards, (gb: GameBoard)=>{\n                    assert(gb._has(pn)); // Whether the piece remains there or has been captured, a piece should always exists\n                                         // in that spot in all possible next boards as it is the other side that's moving.\n                                         // So either our piece stays there or the piece that captured it occupies the spot.\n                    const pieceOnNewBoard: ?IConcretePieceOnSide = gb._get(pn);\n                    if (pieceOnNewBoard != null) {\n                        assert(piece !== null);\n                        return piece.equals(pieceOnNewBoard);\n                    } else throw new Error('bug - should have escaped by now');\n\n                })\n            } else\n                throw new Error('bug - should have escaped this path by now');\n        }\n    }\n\n    numOfPossibleMoves(isSideA: boolean): number {\n        const nextBoards: Array<GameBoard> = GameBoard.boardsOnly(this.nextStates(isSideA));\n        return nextBoards.length;\n    }\n\n    \n    move(pn1: Point, pn2: Point): ?GameBoard {\n        if (!this._has(pn1))\n            return null;\n        else {\n            const piece: ?IConcretePieceOnSide = this._get(pn1);\n            if (piece!=null) {\n                const rv: GameBoard = this.clone();                \n                if (!this.inGrid(pn2))\n                    return null;\n                if (rv._has(pn2)) {\n                    const otherPiece : ?IConcretePieceOnSide = rv._get(pn2);\n                    if (otherPiece != null) {\n                        if (otherPiece.sameSide(piece))\n                            return null;\n                        else\n                            rv._capture(pn2);\n                    } else throw new Error('bug');\n                }\n                // finish the move (if some other piece exists at destination it should have already been captured in the lines above\n                rv.clear(pn1);\n                if (this.isPromotionTriggered(pn1, pn2))\n                    rv.set(pn2, piece.promote());\n                else\n                    rv.set(pn2, piece);\n                return rv;\n            } else throw new Error('bug');\n        }\n    }\n    static populate(board: Map<string, IConcretePieceOnSide>, width: number, height: number, pieceSet: PieceSet, asSideA: boolean, positionNotationsStr: string): void {\n        const positionNotations : Array<string> = positionNotationsStr.replace(/ /g, ''). split(',');\n        for (let piecePosition: string of positionNotations) {\n            const [piece, position] = piecePosition.split('@');\n            const point = Point.fromString(position);\n            assert(_.isInteger(point.x));\n            assert(_.isInteger(point.y));            \n            if (!point.x.between(0, width))\n                throw new Error(`Point ${point} does not lie on the X-axis >=0 and < ${width}`);\n            if (!point.y.between(0, height))\n                throw new Error(`Point ${point} does not lie on the Y-axis >=0 and < ${height}`);            \n            const pnkey = point.toString();\n            const pieceP: ?IConcretePiece = pieceSet.fromCode(piece);\n            if (pieceP!=null) {\n                if (!board.has(pnkey))\n                    board.set(pnkey, pieceP.takeSides(asSideA));\n                else\n                    throw new Error(`something alredy exists in point: ${point}`);\n            } else throw new Error(`Bad notation: ${positionNotationsStr}, contains unknown code: ${piece}`);\n        }\n    }\n    kingIsCaptured(sideA: boolean): boolean {\n        return _.some(this.captured.capturedPieces, (p: IConcretePieceOnSide) => ((p.isSideA===!sideA) && (p.piece.isKing)) ); // when a piece is captured, it switches sides\n    }\n\n    boardImmediateWinSide(): ?boolean { // true if this position is a win for side A, false if it is a win for side B, null for neither\n        \n        {   // check for captured kings\n            const sideAKingIsCaptured: boolean = this.kingIsCaptured(true);\n            const sideBKingIsCaptured: boolean = this.kingIsCaptured(false);\n            if ( sideAKingIsCaptured && !sideBKingIsCaptured) return false;\n            if (!sideAKingIsCaptured &&  sideBKingIsCaptured) return true;\n            if ( sideAKingIsCaptured && sideBKingIsCaptured ) throw new Error(`I shoud never be asked to evalute a position with both kings captured such as the following:\\n${this.toStringFancy()}`);\n        }\n        {   // check for kings that've reached the last line and are unchecked\n            const kingAUncheckedLastLine: boolean = this.kingIsOnLastLineUnchecked( true);\n            const kinthisUncheckedLastLine: boolean = this.kingIsOnLastLineUnchecked(false);\n            if (( kingAUncheckedLastLine)  && (!kinthisUncheckedLastLine)) return true;\n            if ((!kingAUncheckedLastLine)  && ( kinthisUncheckedLastLine)) return false;\n            if ( this.winIfKingReachesFarEnd && ( kingAUncheckedLastLine) && ( kinthisUncheckedLastLine) ) throw new Error(`GB:BKULL I shoud never be asked to evalute a position with both kings unchecked on the last line, such as the following:\\n${this.toStringFancy()}`);\n        }\n        return null;\n    }\n    \n\n    \n    toString(): string {\n        const keys:       Array<string> = Array.from(this.board.keys());\n        const keysSorted: Array<string> = _.sortBy(keys, (xy)=>{\n            const p = Point.fromString(xy);\n            return p.x*MAX_BOARD_DIMENSION+p.y;\n        });\n        const rv = [];\n        for (let key: string of keysSorted) {\n            const piece: ?IConcretePieceOnSide = this.board.get(key);\n            if (piece!=null) {\n                rv.push(`${piece.toString()}@${key.toString()}`);\n            } else throw new Error(`bug key: ${key.toString()} found and yet not found`);\n        }\n        const board = rv.join(', ');\n        return `[${board}] * [${this.captured.toString()}]`;\n    }\n    toStringFancy(): string {\n        return GameBoard.toStringFancy(this);\n    }\n    static toStringFancy(gb): string {\n        const rows=[];\n        for (let j = 0; j < gb.height ; j++) {\n            const column = [];\n            for (let i = 0 ; i < gb.width ; i++) {\n                const piece: ?IConcretePieceOnSide = gb._get(new Point(i, j));\n                if (piece==null)\n                    column.push('.');\n                else {\n                    if (piece != null) {\n                        column.push(piece.toString());\n                    } else throw new Error();\n                }\n            }\n            rows.push(column.join(''));\n        }\n        const board = rows.join('\\n');\n        return `${board}\\n--\\n${gb.captured.toString()}`;\n    }\n    static toStringFancyBoardsOnly(__gameBoards: Map<string, GameBoard>): string {\n        const _gameBoards: Array<GameBoard> = GameBoard.boardsOnly(__gameBoards);\n        const gameBoards: Array<string>  = _gameBoards.map( (x) => x.toStringFancy() );\n        const gameBoardsSliced: Array<Array<string>> = gameBoards.map( (x)=>x.split(/\\r?\\n/) );\n        const gameBoardsSlicedTr = transpose(gameBoardsSliced);\n        let rv =  gameBoardsSlicedTr.map( (x: Array<string>)=> {return x.join('  I  ');}).join('\\n');\n        return rv;\n    }\n    static toStringFancyMovesOnly(movesToGameBoardsMap: Map<string, GameBoard>): string {\n        const movesToGameBoardsArr: Array<[string, GameBoard]> = Array.from(movesToGameBoardsMap.entries());\n        const moves: Array<string> = movesToGameBoardsArr.map( ([k, v])=>k);\n        return `[${moves.join(', ')}]`;\n    }    \n    equals(o: GameBoard): boolean {\n        return this.toString()===o.toString();\n    }    \n}\n\n    \nexports.Point            = Point;\nexports.PieceSet         = PieceSet;\nexports.GameBoard        = GameBoard;\n"]}