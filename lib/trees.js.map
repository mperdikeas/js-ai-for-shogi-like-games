{"version":3,"sources":["../src/trees.js"],"names":["TREE_NODE_ID_SYMBOL_KEY","Node","value","adornment","children","v","console","log","Symbol","for","f","rv","forEach","e","Error","Array","from","values","map","x","o","prevAdorn","edge","node","Map","prevValue","get","set","undefined","_visitStartNode","visitStartNode","cycleDetector","_visit","n","parentN","birthEdge","firstVisit","includes","push","k","_includingThisNode","includingThisNode","descendants","depthFirstTraversal","length","isLeaf","addLeavesOnly","child","printAdornment","_valuePrinter","valuePrinter","s","i","lines","printerVisitor","printNode","hasOwnProperty","isEmpty","line","join","exports"],"mappings":"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","file":"trees.js","sourcesContent":["// @flow\n'use strict';\n\nimport _ from 'lodash';\nimport assert from 'assert';\n\ntype F<V,E> = (n: Node<V, E>, parentN: ?Node<V, E>, birthEdge: ?E)=> void;\ntype FV<V,E> = (n: Node<V, E>)=> boolean;\ntype ValuePrinter<V> = (v: V)=>string;\n\n\nconst TREE_NODE_ID_SYMBOL_KEY: string = 'mjb44-NODE-id';\n\nclass Node<V, E> {\n    value: V;\n    adornment: any;\n    children: ?Map<E, Node<V,E>>;\n\n    constructor(value: V) {\n        this.value = value;\n        this.adornment = null;\n        this.children = null;\n    }\n\n    isAdorned(): boolean {\n        const v = this.adornment!==null;\n        if (false)\n            // $SuppressFlowFinding: access of computed property/element. Indexable signature not found in ...\n            console.log(`isAdorned called on node [${this[Symbol.for(TREE_NODE_ID_SYMBOL_KEY)]}], returning: ${v}`);\n        return v;\n    }\n\n    allChildrenSatisfy(f: FV<V,E>): boolean {\n        let rv: boolean = true;\n        if (this.children!=null) {\n            this.children.forEach( (v:Node<V,E>, e:E) => {\n                if (!f(v))\n                    rv = false;\n            });\n            return rv;\n        } else throw new Error('bad choreography');\n    }\n\n    getChildrenAdornments(): Array<any> {\n        if (this.children!=null) {\n            return Array.from(this.children.values()).map( (x)=>x.adornment);\n        } else throw new Error('bad choreography');\n    }\n\n    adorn(o: any): any {\n        const prevAdorn = this.adornment;\n        this.adornment = o;\n        return prevAdorn;\n    }\n\n    set(edge: E, node: Node<V,E>): ?Node<V,E> {\n        if (this.children === null) {\n            this.children = new Map();\n        }\n        const children: ?Map<E, Node> = this.children;\n        if (children!=null) {\n            const prevValue: ?Node = children.get(edge);\n            children.set(edge, node);\n            return prevValue;\n        } else throw new Error('bug1');\n    }\n\n    setn(edge: E, node: Node<V,E>): void {\n        const prevValue: ?Node = this.set(edge, node);\n        assert(prevValue===undefined);\n    }\n\n    isLeaf(): boolean {\n        return this.children === null;\n    }\n\n    depthFirstTraversal(f: F<V,E>, _visitStartNode: ?boolean): void {\n        const visitStartNode: boolean = _visitStartNode == null ? true : _visitStartNode;\n        const cycleDetector: Array<Node<V,E>> = [];\n        function _visit(n: Node<V,E>, parentN: ?Node<V,E>, birthEdge: ?E, firstVisit: boolean) {\n            if (cycleDetector.includes(n)) throw new Error('cycle detected');\n            cycleDetector.push(n);\n            if (!(firstVisit && !visitStartNode)) {\n                f(n, parentN, birthEdge);\n            }\n            const children: ?Map<E, Node<V,E>> = n.children;\n            if (children != null) {\n                children.forEach( (v: Node<V,E>, k: E) => {\n                    _visit(v, n, k, false);\n                });\n            }\n        }\n        _visit(this, null, null, true);        \n    }\n\n    descendants(_includingThisNode: ?boolean): Array<Node> {\n        const includingThisNode: boolean = _includingThisNode == null ? false : _includingThisNode;\n        const descendants: Array<Node> = [];\n        function f(n : Node) {\n            descendants.push(n);\n        }\n\n        this.depthFirstTraversal(f, includingThisNode);\n        assert(   ((!includingThisNode) && (descendants.length===0) && ( this.isLeaf())) ||\n                  ((!includingThisNode) && (descendants.length>  0) && (!this.isLeaf())) ||\n                  (( includingThisNode) && (descendants.length>  0)) );\n        return descendants;\n    }\n\n    leafs(_includingThisNode: ?boolean): Array<Node<V,E>> {\n        const includingThisNode: boolean = _includingThisNode == null ? false : _includingThisNode;        \n        const rv: Array<Node<V,E>> = [];\n        function addLeavesOnly(n: Node): void {\n            if (n.isLeaf())\n                rv.push(n);\n        }\n        this.depthFirstTraversal(addLeavesOnly, includingThisNode);\n        return rv;\n    }\n\n    edgeThatLeadsTo(n: Node): ?E {\n        assert(!this.isLeaf());\n        const children: ?Map<E, Node> = this.children;\n        if (children != null) {\n            assert(children !== null);\n            const rv: Array<E> = [];\n            children.forEach( function (child: Node, edge: E) {\n                const descendants: Array<Node> = child.descendants(true);\n                if (descendants.includes(n))\n                    rv.push(edge);\n            });\n            if (rv.length > 1) throw new Error('Bug! ${rv.length} edges leading to node: ${n} - impossible if the graph is a tree.');\n            else if (rv.length === 0) return null;\n            else return rv[0];\n        } else throw new Error('bug3');\n    }\n\n    print(printAdornment: boolean, _valuePrinter: ?ValuePrinter<V>): string {\n        let valuePrinter: ValuePrinter<V> = (_valuePrinter==null?(x)=>`${x}`:_valuePrinter);\n        const s: symbol = Symbol.for(TREE_NODE_ID_SYMBOL_KEY);// Symbol();\n        let i: number = 0;\n        const lines: Array<string> = [];\n        const printerVisitor: F<V,E> = function printNode(n: Node<V,E>, parentN: ?Node<V,E>, birthEdge: ?E) {\n            assert( ((parentN==null) && (birthEdge==null)) || ((parentN!=null) && (birthEdge!=null)) );\n            if (!n.hasOwnProperty(s))\n                // $SuppressFlowFinding: access of computed property/element. Indexable signature not found in ...\n                n[s] = i++;\n            if (parentN==null) {\n                assert(parentN===null);\n                assert(birthEdge===null);\n                assert(_.isEmpty(lines));\n                // $SuppressFlowFinding: access of computed property/element. Indexable signature not found in ...\n                let line: string = `ROOT node #${n[s]} with value: ${valuePrinter(n.value)}`;\n                if (printAdornment)\n                    line+=`, adornment: ${n.adornment}`;\n                lines.push(line);\n            } else {\n                if (birthEdge!=null) {\n                    assert(birthEdge!==null);\n                    // $SuppressFlowFinding: access of computed property/element. Indexable signature not found in ...                    \n                    let line: string = `node #${parentN[s]} ~~[${birthEdge}]~~> node #${n[s]} with value: ${valuePrinter(n.value)}`;\n                    if (printAdornment)\n                        line+=`, adornment: ${n.adornment}`;\n                    lines.push(line);\n                } else throw new Error('bug');\n            }\n        };\n        this.depthFirstTraversal(printerVisitor);\n        return lines.join('\\n');\n    }\n}\n\n\nexports.Node = Node;\nexports.TREE_NODE_ID_SYMBOL_KEY = TREE_NODE_ID_SYMBOL_KEY;\n"]}