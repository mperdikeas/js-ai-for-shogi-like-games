{"version":3,"sources":["../src/move-tree-builder.js"],"names":["sourceMapSupport","require","install","moveTreeBuilder","gb","sideToMoveNext","depth","root","_moveTreeBuilder","depthRemaining","boardImmediateWinSide","nextMoves","nextStates","forEach","board","k","n","set","assertConsistent","bestMove","sideA","evalModel","pieceSet","moveTree","evaluateLeaves","console","log","print","pullEvaluationsUp","scoreSelector","Math","max","min","currentlyBestScore","Infinity","selectedEdge","children","v","e","isAdorned","adornment","fromString","Error","dynamicEvaluationOfBoard","adornLeaf","node","isLeaf","adorn","evaluateBoard","value","depthFirstTraversal","currentNode","assertNoRecursion","Symbol","for","allChildrenSatisfy","allChildrenValues","getChildrenAdornments","selectorToUse","thisNodeAdorn","apply","tree","_assertConsistent","expectedSide","newBoard","moveS","side","sideOfMoveSNoPieceSetInfo","theOther","sideThatMovesNext","discoveredSide","_","exports"],"mappings":"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","file":"move-tree-builder.js","sourcesContent":["// @flow\n'use strict';\n\n(function() {\n    const sourceMapSupport = require('source-map-support');\n    sourceMapSupport.install();\n})();\n\nimport assert from 'assert';\nimport _ from 'lodash';\n\nimport not_used from './number-prototype.js';\n\nimport {GameBoard}                       from './board-lib.js';\nimport {Node, TREE_NODE_ID_SYMBOL_KEY}   from './trees.js';\nimport {Side}                            from './side.js';\nimport {theOne}                          from './utils.js';\nimport {Move, BoardMove, DropMove}       from './moves.js';\nimport {EvaluationModel}                 from './eval-model.js';\n\nfunction moveTreeBuilder(gb: GameBoard, sideToMoveNext: boolean, depth: number): Node<GameBoard, string> {\n\n    const root:Node<GameBoard, string> = new Node(gb);\n\n    function _moveTreeBuilder(root: Node<GameBoard, string>, gb: GameBoard, sideToMoveNext: boolean, depthRemaining: number): void {\n        if (depthRemaining===0)\n            return; // put a floor to the recursion if we reached maximum depth\n        if (gb.boardImmediateWinSide()!==null)\n            return; // put a floor to the recursion if we reached a game end state\n        const nextMoves: Map<string, GameBoard> = gb.nextStates(sideToMoveNext);\n        nextMoves.forEach( (board: GameBoard, k: string) => {\n            const n: Node<GameBoard, string> = new Node(board);\n            root.set(k, n);\n            _moveTreeBuilder(n, board, !sideToMoveNext, depthRemaining-1);\n        });\n    }\n\n    _moveTreeBuilder(root, gb, sideToMoveNext, depth);\n    assertConsistent(root);\n    return root;\n}\n\nfunction bestMove(gb: GameBoard, sideA: boolean, depth: number, evalModel: EvaluationModel, pieceSet: Array<IConcretePiece>): any { // BoardMove | DropMove // TODO\n    // TOOD: I am left here, this should return either BoardMove or DropMove (fully qualified piece - not the side only superclass)\n    const moveTree: Node<GameBoard, string> = moveTreeBuilder(gb, sideA, depth);\n    evaluateLeaves(moveTree, evalModel);\n    if (false)\n    console.log(`\\n\\n\\n**** Upon leaves evaluation:\\n${moveTree.print(true)}`);\n    pullEvaluationsUp(sideA, moveTree);\n    if (false)\n    console.log(`\\n\\n\\n**** When evaluations are pulled up:\\n${moveTree.print(true)}`);\n    const scoreSelector : (a: number, b: number)=> number = sideA? Math.max: Math.min;\n    let currentlyBestScore: number  = sideA? -Infinity: Infinity;\n    let selectedEdge: ?string = null;\n    if (moveTree.children!=null) {\n        moveTree.children.forEach( (v: Node<GameBoard, string>, e: string) => {\n            assert(v.isAdorned());\n            if (selectedEdge === null) // initialize the selected edge (for hopeless situations where every move leads to the same infinity outcome and the if below would never be triggered)\n                selectedEdge = e;\n            if (scoreSelector(v.adornment, currentlyBestScore)!=currentlyBestScore) {\n                if (false)\n                console.log(`trying the edge ${e} led to a score of ${scoreSelector(v.adornment, currentlyBestScore)} which is better than the currently bestScore of ${currentlyBestScore}`);\n                selectedEdge = e;\n                currentlyBestScore = scoreSelector(v.adornment, currentlyBestScore);\n            }\n        });\n        if (selectedEdge!=null)\n            return Move.fromString(pieceSet, selectedEdge);\n        else throw new Error(`inconceivable that it was impossible to select an edge`);\n    } else throw new Error(`inconceivable to ask for bestMove on a leaf!`);\n}\n\nfunction dynamicEvaluationOfBoard(gb: GameBoard, sideA: boolean, depth: number, evalModel: EvaluationModel, pieceSet: Array<IConcretePiece>): number {\n    const moveTree: Node<GameBoard, string> = moveTreeBuilder(gb, sideA, depth);\n    evaluateLeaves(moveTree, evalModel);\n    if (false)\n    console.log(`\\n\\n\\n**** Upon leaves evaluation:\\n${moveTree.print(true)}`);\n    pullEvaluationsUp(sideA, moveTree);\n    if (moveTree.adornment!=null) {\n        return moveTree.adornment;\n    } else throw new Error('root node should be adorned after evaluations are pulled up');\n}\n\nfunction evaluateLeaves(moveTree: Node<GameBoard, string>, evalModel: EvaluationModel): void {\n    function adornLeaf(node: Node<GameBoard, string> ):void {\n        if (node.isLeaf())\n            node.adorn(evalModel.evaluateBoard(node.value));\n    }\n    moveTree.depthFirstTraversal(adornLeaf, true);\n}\n\n\nfunction pullEvaluationsUp(sideA: boolean, currentNode: Node<GameBoard, string>, assertNoRecursion: boolean = false): void {\n    if (false)\n        // $SuppressFlowFinding: access of computed property/element. Indexable signature not found in ...\n        console.log(`call to PEU at node: ${currentNode[Symbol.for(TREE_NODE_ID_SYMBOL_KEY)]}`);\n    function isAdorned(n: Node<GameBoard,string>): boolean {\n        return n.isAdorned();\n    }\n    if (currentNode.allChildrenSatisfy(isAdorned)) {\n        let allChildrenValues: Array<any> = currentNode.getChildrenAdornments();\n        let selectorToUse = sideA?Math.max:Math.min;\n        let thisNodeAdorn = selectorToUse.apply(null, allChildrenValues);\n        assert(currentNode.adorn(thisNodeAdorn)===null);\n    } else {\n        if (assertNoRecursion)\n            throw new Error('recursion was not expected');\n        if (currentNode.children!=null) {\n            currentNode.children.forEach( function(n: Node<GameBoard, string>, e: string) {\n                if (!n.isAdorned())\n                    pullEvaluationsUp(!sideA, n);\n            });\n            pullEvaluationsUp(sideA, currentNode, true);\n        } else throw new Error('bug');\n    }\n    assert(currentNode.isAdorned());\n}\n\n\n\nfunction assertConsistent(tree: Node<GameBoard, string>): void {\n    function _assertConsistent(tree: Node<GameBoard, string>, expectedSide: ?Side): void {\n        if (!tree.isLeaf()) {\n            if (tree.children!=null) {\n                if (expectedSide!=null) {\n                    tree.children.forEach( (newBoard: Node<GameBoard, string>, moveS: string)=> {\n                        const side: Side = tree.value.sideOfMoveSNoPieceSetInfo(moveS);\n                        if (side!==expectedSide)\n                            throw new Error();\n                        _assertConsistent(newBoard, side.theOther());\n                    } );\n                } else {\n                    tree.children.forEach( (newBoard: Node<GameBoard, string>, moveS: string)=> {\n                        const side: Side = tree.value.sideOfMoveSNoPieceSetInfo(moveS);\n                        _assertConsistent(newBoard, side.theOther());\n                    } );\n                }\n            } else throw new Error('bug');\n        }\n    }\n    _assertConsistent(tree, null);\n}\n\nfunction sideThatMovesNext(tree: Node<GameBoard, string>): Side {\n\n    assert(!tree.isLeaf());\n    \n    assertConsistent(tree);\n    if (tree.children!=null) {\n        let discoveredSide: ?Side = null;\n            tree.children.forEach( (_: Node<GameBoard, string>, moveS: string)=> {\n                const side: Side = tree.value.sideOfMoveSNoPieceSetInfo(moveS);\n                if (discoveredSide===null)\n                    discoveredSide = side;\n                if ((discoveredSide!==null) && (discoveredSide!=side))\n                    throw new Error();\n            });\n        if (discoveredSide!=null)\n            return discoveredSide;\n        else\n            throw new Error('impossible to be unable to pronounce discovered side on a non-leaf tree');\n    } else throw new Error('bug');    \n}\n\n\nexports.moveTreeBuilder          = moveTreeBuilder;\nexports.sideThatMovesNext        = sideThatMovesNext;\nexports.evaluateLeaves           = evaluateLeaves;\nexports.pullEvaluationsUp        = pullEvaluationsUp;\nexports.bestMove                 = bestMove;\nexports.dynamicEvaluationOfBoard = dynamicEvaluationOfBoard;\n"]}